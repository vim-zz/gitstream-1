{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"/:\\ gitStream","text":"<p>gitStream automates your reviews, so you can focus human effort on what matters most. Not all Pull Requests are the same. Some reviews can be automated, like changes using a specific API (deprecated, sensitive), changes that are non-functional, like docs or tests, or even reformatting code. Automate these reviews to reduce context switches by assigning specific people to review, approve, or even merge simple changes that passed all checks, and more.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Take these three steps to see how gitStream works; later on you can learn about the .cm file, see some automation examples and learn how to create and edit your automation.</p> <ol> <li>Get gitStream for free from GitHub marketplace</li> <li>Add these 2 files <code>.cm/gitstream.cm</code> and <code>.github/workflows/gitstream.yml</code> to your repo</li> <li>Open a new PR to see gitStream in action (You don\u2019t have to merge it)</li> </ol>"},{"location":"#features","title":"Features","text":"<p>Building Custom Rules</p> <ul> <li>PR Complexity </li> <li>Multiple sources</li> <li>Code change variables  </li> <li>Branch details &amp; history</li> </ul> <p>gitStream engine</p> <ul> <li>Auto-merge PRs</li> <li>Custom PR labels</li> <li>Require specific reviewers </li> <li>Automated change requests</li> <li>Increase quality requirements </li> <li>Based on Jinja2 template engine</li> </ul>"},{"location":"#continuous-merge","title":"Continuous Merge","text":"<p>Continuous Merge (CM) is the practice of automating the merge path by classifying pull requests based on change type, size, and complexity to allow work to flow more efficiently.</p> <p>learn more about the .cm file</p> <p>automation examples</p>"},{"location":"automation-actions/","title":"Automation actions","text":"<p>Actions are the end results of the automation described in your <code>.cm</code> file.</p>  <p>Note</p> <p>Items marked with  are under development and are not available yet.</p>"},{"location":"automation-actions/#overview","title":"Overview","text":"<p>gitStream executes actions in the order they are listed. If an action result fails, following actions will not be executed.</p> <ul> <li><code>add-comment</code></li> <li><code>add-label</code></li> <li><code>add-labels</code></li> <li><code>add-reviewers</code></li> <li><code>approve</code></li> <li><code>close</code></li> <li><code>merge</code></li> <li><code>set-required-approvals</code></li> <li><code>require-reviewers</code></li> <li><code>request-changes</code></li> </ul>  <p>Note</p> <p>Multiple actions can be listed in a single automation. The actions are invoked one by one.</p>"},{"location":"automation-actions/#dynamic-actions-arguments","title":"Dynamic actions arguments","text":"<p>Arguments values a dynamic value is supported using expressions based on Jinja2 syntax, and includes gitStream context variables, for example:</p> <pre><code>automations:\n  pr_complexity:\n    if:\n      - true\n    run:\n      - action: add-comment@v1\n        args:\n          comment: \"Estimated {{ branch | estimatedReviewTime }} minutes to review\"\n</code></pre>"},{"location":"automation-actions/#reference","title":"Reference","text":""},{"location":"automation-actions/#add-comment","title":"<code>add-comment</code>","text":"<p>This action, once triggered, adds a comment to the PR.</p> <p>This is a manged action, when a PR updates, the existing comments that were added by gitStream are re-evaluated and those that are not applicable are removed.</p>     Args Usage Type Description     <code>comment</code> Required String Sets the comment, markdown is supported     example<pre><code>automations:\n  senior_review:\n    if:\n      - {{ files | match(term='core/') | some }}\n    run:\n      - action: add-comment@v1\n        args:\n          comment: |\n            Core service update\n            (Updates API)\n</code></pre>"},{"location":"automation-actions/#add-label","title":"<code>add-label</code>","text":"<p>This action, once triggered, adds a label to the PR.</p> <p>This is a manged action, when a PR updates, the existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed.</p>     Args Usage Type Description     <code>label</code> Required String The label text any string can work   <code>color</code> Optional String The color in hex, for example: <code>'FEFEFE'</code> (you can also add <code>#</code> prefix <code>#FEFEFE</code>)     example<pre><code>automations:\n  senior_review:\n    if:\n      - {{ files | match(term='api/') | some }}\n    run:\n      - action: add-label@v1\n        args:\n          label: api-change\n</code></pre>"},{"location":"automation-actions/#add-labels","title":"<code>add-labels</code>","text":"<p>This action, once triggered, adds a list of labels to the PR.</p> <p>This is a manged action, when a PR updates existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed.</p>     Args Usage Type Description     <code>labels</code> Required [String] The list of text labels"},{"location":"automation-actions/#add-reviewers","title":"<code>add-reviewers</code>","text":"<p>This action, once triggered, sets a specific reviewer.</p>     Args Usage Type Description     <code>reviewers</code> Required or <code>team_reviewers</code> [String] Sets reviewers user name   <code>team_reviewers</code> Required or <code>reviewers</code> [String] Sets reviewers teams name, without the <code>@</code> prefix     example<pre><code>automations:\n  senior_review:\n    if:\n      - {{ files | match(term='src/ui/') }}\n    run:\n      - action: add-reviewers@v1\n        args:\n          reviewers: [popeye, olive]\n</code></pre>"},{"location":"automation-actions/#approve","title":"<code>approve</code>","text":"<p>This action, once triggered, approves the PR for merge.</p> <p>This is a manged action, when a PR updates existing approval by gitStream is re-evaluated and removed if no longer applicable.</p> example<pre><code>automations:\n  small_change:\n    if:\n      - {{ source.diff.files | isFormattingChange }}\n    run:\n      - action: approve@v1\n</code></pre>"},{"location":"automation-actions/#close","title":"<code>close</code>","text":"<p>This action, once triggered, close the PR without merging.</p> example<pre><code>automations:\n  close_ui_changes_by_non_ui:\n    if:\n      - {{ files | match(regex=r/src\\/views/) | some }}\n      - {{ pr.author_teams | match(term='ui-team') | nope }}\n    run:\n      - action: add-comment@v1\n        args: \n          comment: |\n            Please contact a member of `ui-team` team if you need to make changes to files in `src/views`\n      - action: close@v1\n</code></pre>"},{"location":"automation-actions/#merge","title":"<code>merge</code>","text":"<p>Once triggered, merge the PR if possible. It can set to wait for required checks to pass or ignore checks.</p>     Args Usage Type Description     <code>wait_for_all_checks</code> Optional Boolean By default <code>false</code>, so only Required checks can block merge, when <code>true</code> the action won't merge even if non-Required check fail   <code>rebase_on_merge</code> Optional Boolean By default <code>false</code>, when merging use rebase mode   <code>squash_on_merge</code> Optional Boolean By default <code>false</code>, when merging use squash mode     example<pre><code>automations:\n  small_change:\n    if:\n      - {{ files | allDocs }}\n    run:\n      - action: merge@v1\n        args:\n          rebase_on_merge: true\n</code></pre>"},{"location":"automation-actions/#set-required-approvals","title":"<code>set-required-approvals</code>","text":"<p>This action, once triggered, blocks PR merge till the desired reviewers approved the PR. The actions fail the check to prevent the PR for merge.</p>  <p>Note</p> <p>You should enable branch protection, so GitHub will prevent merging unless the gitStream action check pass successfully. </p>      Args Usage Type Description     <code>approvals</code> Required Integer Sets the number of required reviewer approvals for merge for that PR     example<pre><code>automations:\n  double_review:\n    if:\n      - {{ files | match(regex=r/agent\\//) | some }}\n    run:\n      - action: set-required-approvals@v1\n        args:\n          approvals: 2\n</code></pre>"},{"location":"automation-actions/#request-changes","title":"<code>request-changes</code>","text":"<p>This action, once triggered, request changes on the PR. As long as request change is set, gitStream will block the PR merge.</p> <p>This is a manged action, when a PR updates existing change request by gitStream is re-evaluated and removed if no longer applicable.</p>     Args Usage Type Description     <code>comment</code> Required [String] The desired request changes comment     example<pre><code>automations:\n  catch_deprecated:\n    if:\n      - {{ source.diff.files | matchDiffLines(regex=r/^[+].*oldFetch\\(/') | some }}\n    run:\n      - action: request-changes@v1\n        args:\n          comment: |\n            You have used deprecated API `oldFetch`, use `newFetch` instead.\n</code></pre>"},{"location":"automation-actions/#require-reviewers","title":"<code>require-reviewers</code>","text":"<p>This action, once triggered, requires a specific reviewer approval.</p>     Args Usage Type Description     <code>reviewers</code> Required [String] Sets reviewers user name, merge is blocked till approved by any of the listed users    <code>also_assign</code> Optional Bool <code>true</code> by default, also assign the specified users as reviewers     example<pre><code>automations:\n  senior_review:\n    if:\n      - {{ files | match(regex=r/src\\/ui\\//) | some }}\n    run:\n      - action: require-reviewers@v1\n        args:\n          reviewers: ['popeye', 'olive']\n</code></pre>"},{"location":"cm-file/","title":"Overview","text":"<p>Continuous Merge automation files have a <code>.cm</code> extension. In a repository,  gitStream loads and parse the <code>.cm</code> directory, which can have multiple automation files, each of which is evaluated independently.</p> <p>You can edit the <code>.cm</code> files and add your own checks and rules. Check out the Automation examples.</p>"},{"location":"cm-file/#the-cm-directory","title":"The .cm directory","text":"<p>The <code>.cm</code> directory is located in the repo root and contains the automation files. </p> <p>Every file is parsed independently, and the parsing results are combined and executed.</p> <p>Specifically:</p> <ol> <li>Automations are allowed to have same name in different <code>.cm</code> files</li> <li>The <code>config</code> section is defined per <code>.cm</code> file</li> <li>Any accessory expression defined in one file cannot be reused in another file </li> </ol>"},{"location":"cm-file/#context-variables","title":"Context variables","text":"<p>gitStream includes a collection of variables called contexts. These variable has all the inputs you need to code your automation, including files names and paths, code that was changed or who did the change. See more here.</p>"},{"location":"cm-file/#filter-functions","title":"Filter functions","text":"<p>Filter functions are essentially callable functions that can be applied to variables. They are called with a pipe operator <code>|</code> and can take arguments inside parentheses <code>( )</code>. The logic expressions are based on Jinja2 syntax, supported by Nunjucks library.</p> <p>See more about the Nunjucks built-in filters here, and about gitStream built-in filters here.</p>"},{"location":"cm-file/#automation-actions","title":"Automation actions","text":"<p>Specify the desired automations that are triggered when all conditions are met, read more here.</p> <p>Each automation includes conditions in an <code>if</code> section and actions in a <code>run</code> section. </p> <p>Conditions: Multiple conditions can be listed for a single automation, with AND relationship between the conditions, hence all listed conditions must pass to invoke the actions. The conditions are evaluated on new Pull Requests or changes to the Pull Request.</p> <p>Actions: Multiple actions can be listed in a single automation, the actions are invoked one by one.</p> <p>PRs that are marked as Draft are ignored by default, you can change that, see <code>config</code> .</p>"},{"location":"cm-file/#schema","title":"Schema","text":"<p>The following sections are used in <code>.cm</code> file to describe the desired automations:</p> <ul> <li><code>manifest</code></li> <li><code>config</code></li> <li><code>automations</code></li> </ul>"},{"location":"cm-file/#manifest","title":"<code>manifest</code>","text":"<p>The first section in a <code>gitstream.cm</code> file is the <code>manifest</code>.</p> <pre><code>manifest: \n  version: 1.0\n</code></pre> <p>The only field required is <code>version</code>.</p>    Key Required Type Description     <code>manifest</code> Y Map The manifest section root   <code>manifest.version</code> Y String Specify the <code>.cm</code> spec version: 0.1, 1.0    <p>The manifest version field is used to parse the <code>.cm</code> file, in the future if breaking changes are introduced to the parser then older automation will be still supported.</p>"},{"location":"cm-file/#config","title":"<code>config</code>","text":"<p>The <code>config</code> section is optional in <code>gitstream.cm</code> file and is used to specify configuration for the way gitStream works.</p>    Key Required Type Default Description     <code>config</code> N Map - The config section root   <code>config.ignore_files</code> N [String] - Specifies files that will not be included in the context variables    <p><code>config.ignore_files</code> supports glob pattern matching that contains list of files to ignore, for example:</p> <pre><code>config:\n  ignore_files:\n    - 'yarn.lock'\n    - 'package-lock.json'\n    - 'openapi.json'\n    - 'ui/src/**/*Model.d.ts'\n</code></pre>"},{"location":"cm-file/#automations","title":"<code>automations</code>","text":"<p>The <code>automations</code> section defines the automations and their conditions. </p> <pre><code>automations:\n  mark_small_pr:\n    if:\n      - {{ checks.size.is.xsmall }}\n    run:\n      - action: add-label@v1\n        args:\n          label: xsmall\n</code></pre> <p>Each automation includes its name, and few fields: <code>if</code> and <code>run</code>.</p>    Key Required Type Description     <code>automations</code> Y Map The automations section root   <code>automations.NAME</code> Y Map User defined name of the automation, can be any string   <code>automations.NAME.if</code> Y Map List of conditions with AND relationship   <code>automations.NAME.run</code> Y Map Actions to run if all conditions are met, invoked one by one    <p>The <code>if</code> field includes the list of conditions. The conditions are checked when a pull request  is opened or changed, if all the conditions pass, the automation is executed.</p> <p>The <code>run</code> field includes the automation to execute. It includes the following fields:</p>    Key Required Type Description     <code>action</code> Y String The action pointer   <code>engine</code> N String The action engine, default is <code>gitstream</code>   <code>args</code> N List The action inputs list    <p>For <code>gitstream</code> engine, the action is specified by: <code>name@version</code></p> <p>gitStream supported actions, see actions.</p>"},{"location":"cm-file/#reusing-checks","title":"Reusing checks","text":"<p>You can define an accessory section, e.g. <code>checks</code>, that defines common conditions, and reuse.  </p> <pre><code>size:\n  is:\n    small: {{ branch.diff.size &lt; 20 }}\n    medium: {{ branch.diff.size &gt;= 20 and branch.diff.size &lt; 100 }}\n    large: {{ branch.diff.size &gt;= 100 }}\nautomations:\n  approve_small:\n    if:\n      - {{ size.is.small }}\n    run:\n      - action: approve@v1\n  mark_small_medium:\n    if:\n      # Check that the PR is either small or medium size \n      - {{ size.is.small or size.is.medium }}\n      # AND its less than 5 minutes review (estimated) \n      - {{ branch | estimatedReviewTime &lt;= 5 }}\n    run:\n      - action: add-label@v1\n        args:\n          label: 'good-size'\n</code></pre>"},{"location":"context-variables/","title":"Context variables","text":"<p>Context variable are the inputs for the automation conditions or checks.</p>  <p>Note</p> <p>Items marked with  are under development and are not available yet.</p>"},{"location":"context-variables/#overview","title":"Overview","text":""},{"location":"context-variables/#context","title":"Context","text":"<p>gitStream includes a collection of variables called contexts. </p> <ul> <li><code>branch</code></li> <li><code>files</code></li> <li><code>source</code></li> <li><code>repo</code></li> <li><code>pr</code></li> </ul>"},{"location":"context-variables/#structures","title":"Structures","text":"<p>The following structures are used in the context objects:</p> <ul> <li><code>GitBlame</code></li> <li> <code>Check</code></li> <li><code>Contributor</code></li> <li><code>FileDiff</code></li> <li><code>FileMetadata</code></li> <li><code>GeneralComment</code></li> <li><code>LineComment</code></li> </ul>  Example of a context object <p>Example of a context object for a PR that changed few lines in a <code>README.md</code> file:</p> <pre><code>{\n  \"branch\": {\n    \"name\": \"new-feature-branch\",\n    \"base\": \"main\",\n    \"diff\": {\n      \"size\": 50,\n      \"files_metadata\": [\n        {\n          \"original_file\": \"README.md\",\n          \"new_file\": \"README.md\",\n          \"deletions\": 0,\n          \"additions\": 2\n        }\n      ]\n    },\n    \"num_of_commits\": 1\n  },\n  \"source\": {\n    \"diff\": {\n      \"files\": [\n        {\n          \"original_file\": \"README.md\",\n          \"new_file\": \"README.md\",\n          \"diff\": \"@@ -10,3 +10,5 @@ This project \\n+\\n+## Intro\",\n          \"original_content\": \"This project \\n\",\n          \"new_content\": \"This project \\n\\n## Intro\"\n        }\n      ]\n    }\n  },\n  \"repo\": {\n    \"contributors\": {\n      \"popeye\": \"46\",\n      \"olive\": \"6\"\n    }\n  },\n  \"files\": [\n    \"README.md\"\n  ]\n}\n</code></pre>"},{"location":"context-variables/#reference","title":"Reference","text":""},{"location":"context-variables/#branch","title":"<code>branch</code>","text":"<p>The <code>branch</code> context contains info regarding the branch changes compared to the base branch. </p>  <p>Note</p> <p>compared to the <code>source</code> context does not include actual source code.</p>     Values Type Description     <code>branch</code> Map Includes the info related to the current branch   <code>branch.author</code> String The branch author (the user that did first commit in the branch). The formatted like author in <code>git-log</code>, e.g. <code>Popeye &lt;popeye@acme.com&gt;</code>   <code>branch.author_name</code> String The branch author name   <code>branch.author_email</code> String The branch author email   <code>branch.base</code> String The main branch, <code>main</code>    <code>branch.commits.messages</code> [String] A list with all the commit messages in this branch   <code>branch.diff.size</code> Integer The sum of line changed: additions, edits and deletions   <code>branch.diff.files_metadata</code> <code>FileMetadata</code> List of changed files including their relative path   <code>branch.name</code> String The current branch, <code>feature-123-branch</code>   <code>branch.num_of_commits</code> Integer The number of commits in the branch    <p>The branch context doesn't include any source code, but only related metadata.</p>"},{"location":"context-variables/#files","title":"<code>files</code>","text":"<p>The <code>files</code> context includes the list of changed files in the branch compared to the main branch.</p>    Values Type Description     <code>files</code> [String] List of all changed files with their full path    <p>For example, a typical <code>files</code> context should look like: </p> <pre><code>[\n  \"README.md\",\n  \"package.json\",\n  \"src/app.js\",\n  \"src/index.js\",\n  \"docs/examples.md\"\n]\n</code></pre>"},{"location":"context-variables/#pr","title":"<code>pr</code>","text":"<p>The <code>pr</code> context includes metadata related to the pull request.</p>    Values Type Description     <code>pr</code> Map Includes the info related to the PR   <code>pr.approvals</code> [String] The of reviewers that approved the PR   <code>pr.author</code> String The PR author name   <code>pr.author_teams</code> String The teams which the PR author is member of   <code>pr.checks</code> <code>Check</code> List of checks, names and status   <code>pr.created_at</code> String The date and time the PR was created   <code>pr.draft</code> Bool <code>true</code> when the PR is marked as Draft/WIP   <code>pr.description</code> String The PR first comment   <code>pr.general_comments</code> <code>GeneralComment</code> TBD   <code>pr.line_comments</code> <code>LineComment</code> TBD   <code>pr.reviewers</code> [String] The list of reviewers set for this PR   <code>pr.status</code> String The PR status: <code>open</code>, <code>requested-changes</code>, <code>approved</code>, <code>merged</code>   <code>pr.title</code> String The PR title   <code>pr.updated_at</code> String The date and time the PR was last updated"},{"location":"context-variables/#repo","title":"<code>repo</code>","text":"<p>The <code>repo</code> context includes metadata related to the repo.</p>    Values Type Description     <code>repo</code> Map Includes the info related to the current repo   <code>repo.git_activity</code> <code>GitActivity</code> Per file and user, the number of lines changed every week for the last 52 weeks   <code>repo.age</code> Integer Number of days since first commit (of any user)   <code>repo.author_age</code> Integer number of days since first commit to this repo   <code>repo.blame</code> <code>GitBlame</code> The percentage each user's lines in a file, the list includes all changed files in the branch. The list is sorted by the <code>ratio</code> field   <code>repo.contributors</code> <code>Contributor</code> List of changed files including their relative path"},{"location":"context-variables/#source","title":"<code>source</code>","text":"<p>The <code>source</code> context includes a list of <code>FileDiff</code> objects that can be used to get insights based on code changes. The changes compared to the latest main branch. </p>    Values Type Description     <code>source.diff.files</code> <code>FileDiff</code> List of changed files with their code changes    <p>The source context include all code changes, it is not safe to share it with unknown services.</p>"},{"location":"context-variables/#check-structure","title":"<code>Check</code> structure","text":"<p> Coming soon</p> <pre><code>{\n  \"name\": String, # The check name\n  \"status\": String, # The check status: `queued`, `in_progress`, `completed`\n  \"conclusion\": String, # The check conclusion: `action_required`, `cancelled`, `failure` `neutral`, `success`, `skipped`, `stale`, `timed_out`\n} \n</code></pre>"},{"location":"context-variables/#contributor-structure","title":"<code>Contributor</code> structure","text":"<p>The <code>repo.contributors</code> mapping includes a list of <code>Contributor</code>, where the user name is used as dynamic key:</p> <pre><code>{\n  USER_NAME: Integer # Number of commits\n} \n</code></pre>"},{"location":"context-variables/#filediff-structure","title":"<code>FileDiff</code> structure","text":"<p>The <code>source.diff.files</code> mapping includes a list of <code>FileDiff</code>:</p> <pre><code>{\n  \"diff\": String, #  The content in diff format `+` for additions, `-` for deletions\n  \"new_content\": String, # The new content in this branch\n  \"new_file\": String, # The name of the file after the changes, including its path\n  \"original_content\": String, #  The content as is in the `main` branch\n  \"original_file\": String, #  The name of the file before the changes, including its path\n} \n</code></pre>"},{"location":"context-variables/#filemetadata-structure","title":"<code>FileMetadata</code> structure","text":"<p>The <code>branch.diff.files_metadata</code> mapping includes a list of <code>FileMetadata</code>:</p> <pre><code>{\n  \"additions\": Integer, # The number of lines edited or added to the file\n  \"deletions\": Integer, # The number of lines removed from the file  \n  \"file\": String, # The name of the file before the changes, including its path\n} \n</code></pre> <p>For example, sum additions in javascript code files:</p> <pre><code>{{ branch.diff.files_metadata | filter(attr='new_file', regex=r/\\.js$|\\.ts$/) | map(attr='additions') | sum }}\n</code></pre>"},{"location":"context-variables/#generalcomment-structure","title":"<code>GeneralComment</code> structure","text":"<pre><code>{\n  \"commenter\": String, # The user that add the comment\n  \"content\": String, # The comment body    \n  \"created_at\": String, # The time on which the comment was created\n  \"updated_at\": String, # The time on which the comment was last updated\n} \n</code></pre>"},{"location":"context-variables/#gitactivity-structure","title":"<code>GitActivity</code> structure","text":"<p>This structure include per changed file, for every user, the number of lines changed every week for the last 52 weeks.</p> <pre><code>{\n  FILE_NAME: # The file name and path\n  { \n    # The git user identifier (String)\n    GIT_USER: {\n      \"week_INDEX\": Integer # Number of lines changed that week\n      # ... for the last 52 weeks \n    }\n  }\n}\n</code></pre> <p>For example: </p> <pre><code>{\n  \"src/utils/service.js\": {\n    \"popeye &lt;popeye@acme.com&gt;\": {\n      \"week_1\": 20, \n      \"week_2\": 15, \n      \"week_10\": 250\n    },\n    \"olive &lt;olive@acme.com&gt;\": {\n      \"week_1\": 3, \n      \"week_3\": 50, \n      \"week_52\": 250\n    }\n  },\n  \"README.md\": {\n    \"popeye &lt;popeye@acme.com&gt;\": {\n      \"week_2\": 15, \n      \"week_3\": 10\n    }\n  }\n}\n</code></pre>"},{"location":"context-variables/#gitblame-structure","title":"<code>GitBlame</code> structure","text":"<p>For each file, a list of user's blame ratio.</p> <pre><code>{\n  FILE_NAME: # The file name and path\n  { \n    # The git user identifier (String)\n    GIT_USER: Integer, # Precentage 0-100, ratio of user's lines / total lines in file\n  }\n}\n</code></pre> <p>For example: </p> <pre><code>{\n  \"src/utils/service.js\": {\n    \"popeye &lt;popeye@acme.com&gt;\": 78,\n    \"olive &lt;olive@acme.com&gt;\": 22,\n  },\n  \"README.md\": {\n    \"popeye &lt;popeye@acme.com&gt;\": 13,\n    \"olive &lt;olive@acme.com&gt;\": 22,\n    \"brutus &lt;brutus@acme.com&gt;\": 65,\n  }\n}\n</code></pre>"},{"location":"context-variables/#linecomment-structure","title":"<code>LineComment</code> structure","text":"<pre><code>{\n  \"commenter\": String, # The user that add the comment \n  \"content\": String, # The comment body    \n  \"created_at\": String, # The time on which the comment was created    \n  \"updated_at\": String, # The time on which the comment was updated    \n  \"start_line\": Integer, # The first line marked for this comment    \n  \"end_line\": Integer, # The last line marked for this comment    \n}\n</code></pre>"},{"location":"custom-filters/","title":"Custom filters","text":"<p>Custom filters are implemented in JavaScript.</p>  <p>Attention</p> <p> Coming soon</p>  <p>You can add custom filters by editing the <code>.cm/filters.js</code> file in your repo.</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n\u2502  \u2514\u2500 filters.js \n</code></pre>"},{"location":"custom-filters/#adding-filters","title":"Adding filters","text":"<p>Filters can have input arguments and return a result which can be any valid JavaScript type.</p> <p>An example for a <code>.cm/filters.js</code>:</p> <pre><code>export default {\n  // The includes() method determines whether an array includes a \n  // certain value among its entries, returning true or false.\n  myIncludes: (list, term) =&gt; {\n    return list.includes(term);\n  },\n\n  // Determine if a number is even or odd\n  isOdd: (n) =&gt; {\n    return parseInt(n) % 2 == 0;\n  }\n}\n</code></pre> <p>Once filters are added it can be used in the <code>.cm</code> files, for example using <code>isOdd</code> filter looks like this:</p> <pre><code>{{ branch.diff.size | isOdd }}\n</code></pre>"},{"location":"custom-filters/#using-npm-packages","title":"Using npm packages","text":"<p>The file is loaded by a node.js runtime, the following packages are pre installed and can be imported and used:</p> <ul> <li><code>child_process</code></li> </ul>"},{"location":"custom-filters/#using-external-tools-results","title":"Using external tools results","text":"<p>Tip: cache result to local file system and reuse in CI/CD</p> <pre><code>const { exec } = require('child_process');\n\nexec('npm run test | wc -l', (err, stdout, stderr) =&gt; {\n  if (err) {\n    // node couldn't execute the command\n    return;\n  }\n\n  // the *entire* stdout and stderr (buffered)\n  console.log(`stdout: ${stdout}`);\n  console.log(`stderr: ${stderr}`);\n  return 123;\n});\n</code></pre> <p>For example:</p> <pre><code># access coverage results\ncoverage:\n  is:\n    # npm run test -&gt; /file/here \n    enough: {{ source | my_coverage &gt; 80 }} # 2 user's filter \n</code></pre>"},{"location":"dry-run-mode/","title":"Dry-run mode","text":"<p>gitStream runs automations as described in <code>.cm/gitstream.cm</code> in the main branch. </p> <p>To allow testing and experimenting with new rules, gitStream supports dry-run mode. Once you open a PR and commit changes to <code>.cm/gitstream.cm</code> in the PR branch, gitStream will stop executing automations described in the main branch for this PR, instead gitStream will parse the automations described in the <code>.cm/gitstream.cm</code> of the PR branch and add a comment in the PR that describes all the automations actions \u2013 without executing the actions.</p>  <p>Note</p> <p>When in dry-run mode, changes to the <code>.cm/gitstream.cm</code> file are ignored when calculating the conditions to help focus on setting the right automations</p>   <p>Once you are satisfied with the results, you can merge the <code>.cm/gitstream.cm</code> into the main branch to enable all new changes.</p>"},{"location":"examples/","title":"Examples","text":"<p>Here are some examples of actions that can be applied on repositories by gitStream.</p>  <p>Tip</p> <p>See full list on the gitStream repository.</p>"},{"location":"examples/#review-efficiency","title":"Review Efficiency","text":""},{"location":"examples/#label-prs-by-complexity","title":"Label PRs by complexity","text":"<p>Automatically add a color-coded label to PRs with the estimated review time.</p> <p>When used, each PR will be annotated with this label. When there are new commits to the PR, gitStream manage the label and replace it with an updated review time when needed.</p>  <pre><code>automations:\n  estimated_time_to_review:\n    if:\n      - true\n    run:\n      - action: add-label@v1\n        args:\n          label: \"{{ calc.etr }} min review\"\n          color: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\n\n# To simplify the automation, this calculation is placed under a unique YAML key.\n# The result is is assigned to `calc.etr` which is used in the automation above.\n# You can add as many keys as you like.\ncalc:\n  etr: {{ branch | estimatedReviewTime }}\n</code></pre>  <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#approve-safe-changes","title":"Approve safe changes","text":"<p>PRs that include only documentation changes are verified and approved by gitStream. In the example below, marked in yellow, the <code>files</code> context is checked by <code>allDocs</code> filter that verifies there are only document files. PRs that pass the check are approved by gitStream.</p>  <pre><code>automations:\n  safe_changes:\n    if:\n      - {{ is.formatting or is.docs or is.tests }}\n    run: \n      - action: add-label@v1\n        args:\n          label: 'safe-changes'\n      - action: approve@v1\n\n# To simplify the automation, this calculation is placed under a unique YAML key.\n# The result is is assigned to `is.formatting`, `is.docs` and `is.tests` which is \n# used in the automation above. You can add as many keys as you like.\nis:\n  formatting: {{ source.diff.files | isFormattingChange }}\n  docs: {{ files | allDocs }}\n  tests: {{ files | allTests }}\n</code></pre>  <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#review-quality","title":"Review Quality","text":""},{"location":"examples/#assign-the-relevant-reviewers-to-prs","title":"Assign the relevant reviewers to PRs","text":"<p>Not every review is equal, getting the right one is important to get high quality feedback. Using <code>rankByGitBlame</code> or <code>rankByGitActivity</code> makes this data driven. </p> <p>For example here, when using <code>rankByGitBlame</code> and setting <code>gt</code> to 25 which stands for the greater-than sign: <code>&gt;</code>, only those who contributed more than 25% of lines overall are selected. Applying <code>random</code> will choose one from the list. </p> <pre><code>automations:\n  the_right_reviewer:\n    if: \n      - true\n    run:\n      - action: add-comment@v1\n        args:\n          comment: |\n            {{ repo | explainRankByGitBlame(gt=25) }}\n      - action: add-reviewers@v1\n        args:\n          reviewers: {{ repo | rankByGitBlame(gt=25) | random }}\n</code></pre>  <p>  Download and add to your repo .cm directory </p>  <p>Using <code>explainRankByGitBlame</code> shows the resulting data in the PR comment.</p>"},{"location":"examples/#mark-prs-without-tests","title":"Mark PRs without tests","text":"<p>PRs that don't have tests changes can be marked automatically.</p> <p>When a PR is opened without any tests, this label is added:</p>  <p>Once the tests are added and committed, gitStream automatically removes the label:</p>  <pre><code>automations:\n  no_tests:\n    if:\n      - {{ files | match(regex=r/(test|spec)/) | nope }}\n    run: \n      - action: add-label@v1\n        args:\n          label: 'missing-tests'\n          color: '#E94637'\n</code></pre>  <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#require-2-approvals-for-complex-prs","title":"Require 2 approvals for complex PRs","text":"<p>Automatically require 2 reviewers for PRs that have more than 100 lines of code changed under the <code>src</code> directory.</p> <p>This ability can be very useful if you want to have more approvals for certain PRs, but rather than increasing the required approvals for all PRs using GitHub repo settings, it allows doing that only for specific PRs.</p> <p>Multiple conditions in the <code>if</code> section has AND relationship and must all be true for the automation to execute.</p> <pre><code>automations:\n  double_review:\n    if:\n      - {{ branch | estimatedReviewTime &gt;= 30 }}\n      - {{ files | length &gt;= 10 }}\n      - {{ files | match(regex=r/src\\//) | some }}\n    run:\n      - action: set-required-approvals@v1\n        args:\n          approvals: 2\n</code></pre>  <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#share-knowledge","title":"Share knowledge","text":"<p>When setting <code>lt</code> to 50, which stands for the less-than sign: <code>&lt;</code>, only those who contributed less than 50% of lines overall are selected. Applying <code>random</code> will pick one from the list.</p> <pre><code>automations:\n  share_knowledge:\n    if:\n      - true\n    run:\n      - action: add-reviewers@v1\n        args:\n          reviewers: {{ repo | rankByGitBlame(lt=50) | random }}\n</code></pre>  <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#review-policy","title":"Review Policy","text":""},{"location":"examples/#close-prs-when-touching-out-of-scope-files","title":"Close PRs when touching out-of-scope files","text":"<p>This action, once triggered, close the PR without merging.</p> <p>You can also replace <code>close</code> with <code>requested-changes</code> to leave the PR open but request to undo the UI changes.</p> <pre><code>automations:\n  close_ui_changes_by_non_ui:\n    if:\n      - {{ files | match(regex=r/src\\/views/) | some }}\n      - {{ pr.author_teams | match(term='ui-team') | nope }}\n    run:\n      - action: add-comment@v1\n        args: \n          comment: |\n            Please contact a member of `ui-team` team if you need to make changes to files in `src/views`\n      - action: close@v1\n</code></pre>  <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#assign-mentors-to-new-contributors","title":"Assign mentors to new contributors","text":"<p>During the first 21 days, a contributor is assigned automatically to get reviews by specific people. By changing <code>21</code> you can add or reduce the amount of time.</p> <p>Make sure to change the reviewers according to your team members.</p>  <pre><code>automations:\n  junior:\n    if:\n      - {{ repo.author_age &lt; 21 and (repo.age - repo.author_age) &gt;= 21 }}\n    run:\n      - action: add-label@v1\n        args:\n          label: 'first-weeks'\n          color: '#FBBD10'\n      - action : add-comment@v1\n        args:\n          comment: |\n            During your first 21 days, your team lead will be assigned to review your PRs.\n      - action: add-reviewers@v1\n        args:\n          reviewers: [popeye]\n</code></pre>  <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#request-changes-on-deprecated-apis","title":"Request changes on deprecated APIs","text":"<p>For example, assume we have an old API <code>callElvis</code> we want to switch from to a new API <code>callGaga</code>, gitStream can review and trigger a change request automatically when the PR includes use of the deprecated API.</p> <p>This pattern allows defining best practices in <code>.cm</code> code. </p>  <pre><code>automations:\n  {% for item in deprecated %}\n  # Automation names should be unique, therefore the iteration number postfix\n  catch_deprecated_components_{{ loop.index }}:\n    if:\n      - {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\n    run:\n      - action: add-label@v1\n        args:\n          label: 'deprecated-component'\n          color: '#FF0000'\n      - action: request-changes@v1\n        args:\n          comment: |\n            `{{ item.old }}` component is deprecated, use `{{ item.new }}` instead\n  {% endfor %}\n\n# This list includes the deprecated items\ndeprecated:\n  - regex: r/callElvis/\n    old: Elvis\n    new: Gaga\n  - regex: r/callOldAPI/\n    old: callOldAPI\n    new: callBetterAPI\n</code></pre>  <p>  Download and add to your repo .cm directory </p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#what-permissions-needed","title":"What permissions needed?","text":"<p>In your repo permissions, make sure GitHub actions are permitted:</p> <p>Go to Repo's settings &gt; Actions &gt; General &gt; Actions permissions</p> <p>Choose which repositories are permitted to use GitHub Actions.</p> <p>[x] Allow all actions and reusable workflows</p>"},{"location":"faq/#does-gitstream-services-have-access-to-my-code","title":"Does gitStream services have access to my code?","text":"<p>Like any other CI/CD automation, the source code is being scanned in the repo and is not shared with any external services. Only metadata that relates and affects the workflow is shared to allow rule based automation on the repo.</p>"},{"location":"faq/#why-does-gitstream-require-permission-to-write-code","title":"Why does gitStream require permission to write code?","text":"<p>In order to support automations that either Approve or Merge PRs, GitHub API requires code write scope.</p>"},{"location":"faq/#what-repos-are-supported","title":"What repos are supported?","text":"<p>Any repo in GitHub is supported. More Git providers are planned soon.</p>"},{"location":"faq/#do-i-need-vs-code-to-use-gitstream","title":"Do I need VS Code to use gitStream?","text":"<p>No. gitStream is a CM automation system, nevertheless, developers can benefit from having the VS Code  extension as it presents in the editor what rules can be used to simplify their workflow.</p>"},{"location":"faq/#custom-filter-functions","title":"Custom filter functions","text":"<p>Coming soon.</p>"},{"location":"faq/#is-there-cm-syntax-highlighting","title":"Is there .cm syntax highlighting?","text":"<p>The <code>.cm</code> file use YAML with JINJA2, in order for your favorite editor to choose automatically the right syntax, you can use modelines.</p> <p>Add the following line to the top of the <code>.cm</code> file (the default has it already): </p> <pre><code># -*- mode: yaml -*-\n</code></pre> <p>Get a plug-in that enable modelines, popular ones are:</p> <ul> <li>VS Code: Modelines</li> <li>Sublime Text: Emacs-like Sublime Modeline</li> <li>Vim Modeline magic</li> </ul>"},{"location":"faq/#i-have-an-issue-i-can-seem-to-solve-what-should-i-do","title":"I have an issue I can seem to solve, what should I do?","text":"<p>Go to our issues page and check if there are any similar issues already reported, if not create a new issue with all the details so we can take a look.</p> <p>Found a bug? Create a new item in the project's issues</p>"},{"location":"filter-functions/","title":"Filter functions","text":"<p>Filters can change the look and format of the source data, or even generate new data derived from the input values. What's important is that the original data is replaced by the result of transformations, and that's what ends up in rendered templates.</p>  <p>Note</p> <p>Items marked with  are under development and are not available yet.</p>"},{"location":"filter-functions/#overview","title":"Overview","text":"<p>The following functions are supported in addition to the built-in functions provided by Nunjucks.</p>"},{"location":"filter-functions/#low-level-functions","title":"Low level functions","text":"Function Input Args Output     <code>every</code>Checks whether all element in the list are <code>true</code> [Bool] - Bool   <code>filter</code>Reduce list of items into a list of same items that match the specified term [String][Object] <code>regex</code>, <code>term</code>, <code>list</code>, <code>attr</code> [String][Object]   <code>includes</code>Check if substring match String <code>regex</code>, <code>term</code>, <code>list</code> Bool   <code>map</code>Maps each object in a list into their specified attribute value [Object] <code>attr</code> [Object]   <code>match</code>Maps list of items into a list of booleans that match the specified term [String][Object] <code>regex</code>, <code>term</code>, <code>list</code> <code>attr</code> [Bool]   <code>nope</code>Checks whether all element in the list are <code>false</code> [Bool] - Bool   <code>reject</code>Inverse of <code>filter</code>, the result list contains non-matching items [String][Object] <code>regex</code>, <code>term</code>, <code>list</code>, <code>attr</code> [String][Object]   <code>some</code>Checks whether at least one element in the list is <code>true</code> [Bool] - Bool"},{"location":"filter-functions/#high-level-functions","title":"High level functions","text":"Function Input Args Output     <code>allDocs</code>Checks the list includes only documents files - Bool   <code>allImages</code>Checks the list includes only images files - Bool   <code>allTests</code>Checks the list includes only tests files - Bool   <code>estimatedReviewTime</code>Estimated review time in minutes branch - Integer   <code>extensions</code>Lists all the unique file extensions [String] - [String]   <code>explainRankByGitBlame</code> Short markdown text explaining rankByGitBlame results <code>repo</code> <code>gt</code>, <code>lt</code> [String]   <code>isFirstCommit</code>Checks if its the author first commit in the repo <code>repo.contributors</code> String Bool   <code>isFormattingChange</code>Checks that only formatting changed [<code>FileDiff</code> ] - Bool   <code>matchDiffLines</code>Match every line in diff [<code>FileDiff</code> ] <code>regex</code>, <code>ignoreWhiteSpaces</code> [Bool]   <code>rankByGitActivity</code>Get list of contributors based on <code>git-commit</code> activity <code>repo</code> <code>gt</code>, <code>lt</code> [String]   <code>rankByGitBlame</code>Get list of contributors based on <code>git-blame</code> results <code>repo</code> <code>gt</code>, <code>lt</code> [String]"},{"location":"filter-functions/#named-arguments","title":"Named arguments","text":"<p>Some functions supports named arguments, many of these repeat in different functions.</p> <p><code>term</code> - a single string, used as substring to match with the matched item.</p> <p><code>list</code> - a list of strings, trying to match any of the listed substrings with the matched item.</p> <p><code>regex</code> - a single string, used as regular expression to with the matched item. A regular expression can be created just like JavaScript, but needs to be prefixed with r, for example <code>r/^foo.*/g</code>, for more info see Nunjucks. </p> <p><code>globs</code> - a key to an element in the <code>.cm</code> that holds a list of strings, used as glob pattern test on the matched item. For more info, see Wikipedia.</p> <p><code>attr</code> - a key in the element to use when doing the requested operation.</p> <p>For example, the following expressions provide an identical result:</p> <pre><code>- {{ 'something' | includes(regex=r/^some.*/) }}\n- {{ 'something' | includes(term='some') }}\n- {{ 'something' | includes(list=['some']) }}\n</code></pre>"},{"location":"filter-functions/#reference","title":"Reference","text":""},{"location":"filter-functions/#every","title":"<code>every</code>","text":"<p>Checks whether all element in the list are\u00a0<code>true</code>. In case the list of elements is empty, it will return <code>false</code>.</p>     Argument Usage Type Description     - Input [Bool] List of booleans   - Output Bool Returns <code>true</code> when all list items are <code>true</code>     <p>For example, check that all changes are in either 'src' or 'dest' directories:</p> <pre><code>{{ files | match(list=['src', 'dest']) | every }}\n</code></pre>"},{"location":"filter-functions/#filter","title":"<code>filter</code>","text":"<p>Creates a shallow copy of a portion of a given list, filtered down to just the elements that match the given term. You can use either a single term, regex, or a list of terms to match with.</p>     Argument Usage Type Description     - Input [String][Object] The list of strings to match, or list of objects if <code>attr</code> is used   <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match with the input items   <code>attr</code> Input  (optional) String match a named attribute in the input object   - Output [String][Object] The list with only the matching items     <p>For example, check if all changes to JavaScript files are in tests directory:</p> <pre><code>{{ files | filter(regex=r/\\.js$/) | match(regex=r/tests\\/) | every }}\n</code></pre> <p>For example, check if all changes to JavaScript files are formatting:</p> <pre><code>{{ source.diff.files | filter(attr='new_file', regex=r/\\.js$/) | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#includes","title":"<code>includes</code>","text":"<p>Determines whether a string includes a certain substring. You can use either a single term, regex, or a list of terms to match with.</p>     Argument Usage Type Description     - Input String The list of strings to match   <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Substring term to match   - Output Bool <code>true</code> if search terms matches     <p>Check string matches either of the terms:</p> <pre><code>{{ 'something' | includes(list=['any', 'thing']) }}\n</code></pre>"},{"location":"filter-functions/#map","title":"<code>map</code>","text":"<p>Creates a new list populated with the values of the selected attribute of every element in the input list. </p>     Argument Usage Type Description     - Input [Object] The list of objects to map, see context for valid inputs   <code>attr</code> Input String Object attribute to select   - Output [Object] List of the selected object attributes     <p>For example, the <code>source.diff.files</code> context holds a list of <code>FileDiff</code> , each has <code>new_file</code> attribute. You can create a list of all the new file names by mapping to the <code>new_file</code> attribute and then check if there are changes to any <code>handler.js</code> file:</p> <pre><code>{{ source.diff.files | map(attr='new_file') | match(term='handler.js') | some }}\n</code></pre>"},{"location":"filter-functions/#match","title":"<code>match</code>","text":"<p>Return <code>true</code> for each element in the list that match the search term.</p>     Argument Usage Type Description     - Input [String][Object] The list of strings or if <code>attr</code> used the list of objects   <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match   <code>attr</code> Input String match a named attribute in the input object   - Output [Bool] <code>true</code> for every matching item     <p>For example, to check if all code changes are in the <code>tests</code> directory:</p> <pre><code>{{ files | match(regex=r/tests\\//) | every }}\n</code></pre> <p>For example, to check if there are code changes with specific function call:</p> <pre><code>{{ source.diff.files | match(attr='diff', term='myFunction') | some }}\n</code></pre>"},{"location":"filter-functions/#nope","title":"<code>nope</code>","text":"<p>The inverse of <code>every</code>, checks whether all element in the list are\u00a0<code>false</code>. In case the list of elements is empty, it will return <code>false</code>.</p>     Argument Usage Type Description     - Input [Bool] List of booleans   - Output Bool Returns <code>true</code> when all list items are <code>false</code>     <p>For example, check that no changes in either 'src' or 'dest' directories:</p> <pre><code>{{ files | match(list=['src', 'dest']) | nope }}\n</code></pre>"},{"location":"filter-functions/#reject","title":"<code>reject</code>","text":"<p>Creates a shallow copy of a portion of a given list, filtered down to just the elements that does not match the given term. You can use either a single term, regex, or a list of terms to match with.</p>     Argument Usage Type Description     - Input [String][Object] The list of strings to match, or list of objects if <code>attr</code> is used   <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match with the input items   <code>attr</code> Input  (optional) String match a named attribute in the input object   - Output [String][Object] The list with only the non-matching items     <p>For example, check if all changes, but JavaScript files are in tests directory:</p> <pre><code>{{ files | reject(regex=r/\\.js$/) | match(regex=r/tests\\//') | every }}\n</code></pre> <p>For example, check if all changes except for <code>config.json</code> files are formatting:</p> <pre><code>{{ source.diff.files | reject(attr='new_file', regex=r/config\\.json$/) | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#some","title":"<code>some</code>","text":"<p>Checks whether any element in the list is\u00a0<code>true</code>. In case the list of elements is empty it will return <code>false</code>.</p>     Argument Usage Type Description     - Input [Bool] List of booleans   - Output Bool Returns <code>true</code> when any of the items is <code>true</code>     <pre><code>{{ files | match(list=['src', 'dest']) | some }}\n</code></pre>"},{"location":"filter-functions/#alldocs","title":"<code>allDocs</code>","text":"<p>Return <code>true</code> if the input list includes only documents based on file extensions.</p>     Argument Usage Type Description     - Input <code>files</code> The list of changed files with their path   - Output Bool <code>true</code> if all file extensions are of docs     <p>Doc files extensions are: <code>md</code>, <code>mkdown</code>, <code>txt</code>, <code>rst</code>.</p> <pre><code>{{ files | allDocs }}\n</code></pre>"},{"location":"filter-functions/#allimages","title":"<code>allImages</code>","text":"<p>Return <code>true</code> if the input list includes only images based on file extensions.</p>     Argument Usage Type Description     - Input <code>files</code> The list of changed files with their path   - Output Bool <code>true</code> if all file extensions are of images     <p>Image file extensions are: <code>svg</code>, <code>png</code>, <code>gif</code>.</p> <pre><code>{{ files | allImages }}\n</code></pre>"},{"location":"filter-functions/#alltests","title":"<code>allTests</code>","text":"<p>Return <code>true</code> if the input list includes only tests based on file's path and name.</p>     Argument Usage Type Description     - Input <code>files</code> The list of changed files with their path   - Output Bool <code>true</code> if all file tests based on name and path     <p>Test files must include the substring <code>test</code> or <code>spec</code> in its name or path.</p> <pre><code>{{ files | allTests }}\n</code></pre>"},{"location":"filter-functions/#estimatedreviewtime","title":"<code>estimatedReviewTime</code>","text":"<p>Returns the estimated review time in minutes based on statistical model. For the estimation the model uses additions and deletions statistics grouped by the file types and additional information about the commits and base branch.</p>     Argument Usage Type Description     - Input <code>branch</code> Branch meta data   - Output Integer the estimated time for review in minutes     <pre><code>{{ branch | estimatedReviewTime }}\n</code></pre>"},{"location":"filter-functions/#extensions","title":"<code>extensions</code>","text":"<p>Expects <code>files</code> and provide a list of all unique file extensions.</p>     Argument Usage Type Description     - Input <code>files</code> The list of changed files with their path   - Output [String] List of all unique file extensions     <p>For example, check that only one file type was changed:</p> <pre><code>{{ files | extensions | length == 1 }}\n</code></pre>"},{"location":"filter-functions/#explainrankbygitblame","title":"<code>explainRankByGitBlame</code>","text":"<p>This filter helps to explain the results of <code>rankByGitBlame</code>, the output is in Markdown format that can be used in a PR comment.</p>     Argument Usage Type Description     - Input <code>repo</code> The <code>repo</code> context variable   <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold   <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold   - Output String Explaining <code>rankByGitBlame</code> results in markdown format     <p>For example:</p> <pre><code>automations:\n  the_right_reviewer:\n    if: \n      - true\n    run:\n      - action: add-reviewers@v1\n        args:\n          reviewers: {{ repo | rankByGitBlame(gt=50) }}\n      - action: add-comment@v1\n        args:\n          comment: |\n            {{ repo | explainRankByGitBlame(gt=50) }}\n</code></pre> <p>Note the comment starts with <code>|</code> and a <code>new-line</code> as <code>explainRankByGitBlame</code> generates a multiline comment.</p>"},{"location":"filter-functions/#isfirstcommit","title":"<code>isFirstCommit</code>","text":"<p>Return <code>true</code> if it's the author first commit in the repo.</p>     Argument Usage Type Description     - Input <code>repo.contributors</code> List of contributors in the repo   - Input String The contributor name   - Output Bool <code>true</code> if its the first commit of the selected contributor     <pre><code>if: \n  - {{ repo.contributors | isFirstCommit(branch.author) }}\nrun: \n  - action: add-comment@v1\n    args:\n      comment: Welcome {{branch.author}}!\n</code></pre>"},{"location":"filter-functions/#isformattingchange","title":"<code>isFormattingChange</code>","text":"<p>Return <code>true</code> if all file diffs are validated as formatting changes.</p> <p>Support source code languages: JavaScript, TypeScript, JSON, YAML and HTML.</p> <p>If changes in other formats detected, the filter will return <code>false</code>.</p>     Argument Usage Type Description     - Input <code>source.diff.files</code> List of file diffs   - Output Bool <code>true</code> if the all code changes are non functional     <pre><code>{{ source.diff.files | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#matchdifflines","title":"<code>matchDiffLines</code>","text":"<p>Checks diff for matching lines.</p>     Argument Usage Type Description     - Input [Object] The list of objects   <code>regex</code> Input String Regex term to match with the input items, use <code>\\\\</code> for <code>\\</code>   <code>ignoreWhiteSpaces</code> Input Bool <code>false</code> by default, match a named attribute in the input object    <code>caseSensitive</code> Input Bool <code>true</code> by default, ignore case when matching terms   - Output [Bool] <code>true</code> for every matching object     <p>For example, to check if all the changes are of adding prints and ignore white spaces:</p> <pre><code>{{ source.diff.files | matchDiffLines(regex=r/^\\+.*console\\.log/, ignoreWhiteSpaces=true) | every }}\n</code></pre>"},{"location":"filter-functions/#rankbygitactivity","title":"<code>rankByGitActivity</code>","text":"<p>Get list of contributors based on <code>git-commit</code> activity.</p> <p>The <code>repo</code> context includes all the changed files, for each file it includes each  contributor number of lines changed every week over the last 52 weeks, based on <code>git-commit</code>. </p> <p>These functions compare each contributor changes per week and yield an average percentage of contribution for any given file. For example, in a certain week a file had 500 line changed, 200 by a first user, while 3 other users changed 100 lines each. So the score for the first user in that week will be 40 (200/500 in %). The function then average the score for each user for the selected time period. </p> <p>Then you can use the thresholds to get the right reviewer.</p>     Argument Usage Type Description     - Input <code>repo</code> The <code>repo</code> context variable   <code>weeks</code> Input Integer The number of last weeks to include   <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold   <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold   - Output [String] The list of users based on their code score comparison     <p>Check if the branch author is a rookie</p> <pre><code>active_coders: {{ repo | rankByGitActivity(gt=50, weeks=12) }}\n</code></pre>"},{"location":"filter-functions/#rankbygitblame","title":"<code>rankByGitBlame</code>","text":"<p>Get list of contributors based on <code>git-blame</code> results</p> <p>The <code>repo</code> context includes all the changed files, for each file it includes the  contributors' percentage of lines in the file, based on <code>git-blame</code>. </p> <p>This function sums all these percentages per user and yield an average percentage of contribution. Then you can use the thresholds to get the right reviewer.</p> <p>The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the <code>git-blame</code> output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines.</p>     Argument Usage Type Description     - Input <code>repo</code> The <code>repo</code> context variable   <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold   <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold   - Output [String] The list of users based on their code score comparison, sorted by rank - first has highest score     <p>Example of the filter output, note the output are GitHub users in the example: <pre><code>[\n  \"PopeyeUser\",\n  \"olive_user\",\n  \"BRUTUS_USER\"\n]\n</code></pre></p> <p>Get the most significant contributors for the PR files:</p> <pre><code>contributors: {{ repo | rankByGitBlame(gt=30) }}\n</code></pre> <p>Check if the branch author is a rookie</p> <pre><code>is_rookie: {{ repo | rankByGitBlame(lt=15) | match(term=branch.author) | some }}\n</code></pre>"},{"location":"github-app-setup/","title":"GitHub app installation","text":"<p>To start using gitStream with GitHub source code hosting, install the gitStream app from the GitHub Apps marketplace.</p> <p>gitStream can be installed for one repo, specific repos, or all repos in your organization. </p> <p>Note: we recommend installing for all repositories, as it will also cover new repos you add in the future. You can change this any time if you change your mind.</p> <p>The permissions are: </p>    Permissions Reason     Write access to dedicated gitStream app files Used to set up the gitStream workflow files   Write access to code To allow gitStream to approve PRs once all conditions are met   Read access to administration, issues, and metadata To read the code on monitored repositories   Read and write access to actions, checks, pull requests, and workflows Trigger workflows, create and update pull requests and their checks, and modify workflow files   User email Used to identify users    <p>Once installation completes, the following files are added to each of the selected repos under their root directory.</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre>    File and path Customizable Reason     <code>.cm/*.cm</code> Y Under the repo's <code>.cm</code> directory, any file that ends with <code>.cm</code> will be used by gitStream to specify automation rules, you can edit these files   <code>.github/workflows/gitstream.yml</code> N Used by gitStream to execute automation in your repo so source code doesn't get to outside services"},{"location":"github-app-setup/#set-github-repo-settings","title":"Set GitHub repo settings","text":"<p>Attention</p> <p>To get the full potential using gitStream, you need to set it as a required check.</p>  <p>To make sure gitStream can block PRs from merging under certain conditions, set the following:</p> <ol> <li>Go to repo <code>settings</code></li> <li>On the left panel select <code>Code and automation</code> &gt; <code>Branches</code> </li> <li>Set <code>Branch protection rules</code> for your desired branch </li> <li>Enable <code>Require status checks to pass before merging</code></li> <li>Search for <code>status checks in the last week for this repository</code></li> <li>Select <code>gitStream.cm</code> as required check</li> </ol>"},{"location":"github-installation/","title":"Welcome to gitStream","text":"<p>To start using gitStream:</p> <ol> <li> <p>Make sure you installed the gitStream app from GitHub marketplace</p> </li> <li> <p>Add the following 2 files into your repo's default branch  (usually <code>master</code> or <code>main</code>):</p> </li> <li> <p><code>.cm/gitstream.cm</code></p> </li> <li><code>.github/workflows/gitstream.yml</code></li> </ol> <p>Copy-paste from here:</p>  <code>.cm/gitstream.cm</code> <code>.github/workflows/gitstream.yml</code>   <pre><code># -*- mode: yaml -*-\n\nmanifest:\n  version: 1.0\n\n# The `automations` section includes a list of automation that applies \n# to the repository in which gitStream is installed. Each automation has an \n# `if` key with a list of the necessary assertions, as well as a `run` key with a\n# list of all actions. All the listed assertions need to pass in order \n# for the following actions to be executed (there is AND relation between conditions).\n\n# Each automation under the `automations` section is independent of the others. \n# Every time a PR is opened or changed, the automation's conditions are evaluated (the `if`). \n# The actions under `run` are executed one by one if all the conditions pass. \n\n# Conditions consists of an expression, which are wrapped with double curly braces, and \n# includes a context variable like `files` and filter functions like `length`. Filters \n# functions are essentially functions that can be applied to context variables. They are \n# called with a pipe operator (|) and can take arguments. Read more on https://docs.gitstream.cm\n\nautomations:\n  # This is the name of the review automation. You can use whatever name, a meaningful name \n  # will help to identify it in the future. Each automation name in this file should be unique.\n  estimated_time_to_review:\n    if:\n      - true\n    run:\n      - action: add-label@v1\n        args:\n          label: \"{{ calc.etr }} min review\"\n          color: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\n\n  safe_changes:\n    # The `if` key has a list of conditions, each condition is specified as a Jinja expression\n    # in a double curly braces. Expressions are evaluated by gitStream on a PR when triggered.\n    if:\n      # Given the PR code changes, check that only formatting changes were made \n      - {{ is.formatting or is.docs or is.tests }}\n    # `run` key has a list of actions, which are executed one by one whenever the automation \n    # conditions are met. \n    run: \n      # When the changes are validated as formatting only, you can help to speed up the review \n      # by adding a label that marks it accordingly.\n      - action: add-label@v1\n        args:\n          label: 'safe-changes'\n      # You can uncomment the following action to get gitStream can to automatically approve \n      # such PRs to save reviewers time for such changes.\n      # - action: approve@v1\n\ncalc:\n  etr: {{ branch | estimatedReviewTime }}\nis:\n  formatting: {{ source.diff.files | isFormattingChange }}\n  docs: {{ files | allDocs }}\n  tests: {{ files | allTests }}\n</code></pre>   <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\n\nname: gitStream workflow automation\n\non:\n  workflow_dispatch:\n    inputs:\n      client_payload:\n          description: The Client payload\n          required: true\n      full_repository:\n          description: the repository name include the owner in `owner/repo_name` format\n          required: true\n      head_ref:\n          description: the head sha\n          required: true\n      base_ref:\n          description: the base ref \n          required: true\n      installation_id:\n          description: the installation id\n          required: false\n      resolver_url:\n          description: the resolver url to pass results to\n          required: true\n      resolver_token:\n          description: Optional resolver token for resolver service\n          required: false\n          default: ''\n\njobs:\n  gitStream:\n    timeout-minutes: 5\n    # uncomment this condition, if you dont want any automation on dependabot PRs\n    # if: github.actor != 'dependabot[bot]'\n    runs-on: ubuntu-latest\n    name: gitStream workflow automation\n    steps:\n      - name: Evaluate Rules\n        uses: linear-b/gitstream-github-action@v1\n        id: rules-engine\n        with:\n          full_repository: ${{ github.event.inputs.full_repository }}\n          head_ref: ${{ github.event.inputs.head_ref }}\n          base_ref: ${{ github.event.inputs.base_ref }}\n          client_payload: ${{ github.event.inputs.client_payload }}\n          installation_id: ${{ github.event.inputs.installation_id }}\n          resolver_url: ${{ github.event.inputs.resolver_url }}\n          resolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre>"},{"location":"how-it-works/","title":"How it works","text":"<p>Every time a dev opens a new Pull Request or changes a Pull Request, gitStream is triggered. Next, the <code>.cm</code> file is used to determine which automatic actions are invoked based on their conditions. The resulting actions use GitHub API to achieve the desired outcome.</p> <p>The next steps are common practice of changing code in repo:</p> <ol> <li>Create a feature branch </li> <li>Commit changes  </li> <li>Push branch to remote repo </li> <li>Open Pull Request </li> </ol> <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   branch feature\n   commit id: \"C\"\n   commit id: \"D\"\n   commit id: \"E\"\n   checkout main\n   commit id: \"F\"\n   commit id: \"G\"</code></pre> <p>When a new PR is opened, several actors are running:</p> <ol> <li>GitHub API</li> <li>gitStream app which you have installed from the marketplace </li> <li>gitStream workflows action that was placed in <code>.github/workflows/gitstream.yml</code> and pulls another agent action from <code>linear-b/gitstream-github-action@v1</code></li> </ol> <p>Once a new PR is opened (or changed) the following process occurs:</p> <ol> <li>gitStream gets event for the new PR </li> <li>gitStream calls the installed action in <code>.github/workflows/gitstream.yml</code></li> <li>The installed action pulls and runs gitStream action <code>linear-b/gitstream-github-action@v1</code>. </li> <li>This action runs locally in the repo and relies on </li> <li>The current branch is used to check which automations are valid from <code>.cm/gitstream.cm</code></li> <li>The action calls to gitStream app with metadata</li> <li>gitStream app returns results</li> <li>The list of applicable automations are sent to the gitStream GitHub app</li> <li>gitStream GitHub app iterates over the automations and invokes each action using GitHub APIs</li> <li>The PR gets updated according to the desired automations</li> </ol> <p>At the end, the PR is ready for further review or merge.</p> <p>The following diagram describes the flow:</p> <pre><code>sequenceDiagram\n  autonumber\n  GitHub API-&gt;&gt;gitStream app: new PR\n  gitStream app-&gt;&gt;gitStream GitHub action: run \n  activate gitStream GitHub action\n  gitStream GitHub action-&gt;&gt;gitStream GitHub action: pull agent action\n  gitStream GitHub action-&gt;&gt;gitStream repo agent: run\n  activate gitStream repo agent\n  gitStream repo agent-&gt;&gt;gitStream repo agent: parse the `.cm` rules\n  gitStream repo agent-&gt;&gt;gitStream app: API calls (metadata read-only)\n  gitStream app-&gt;&gt;gitStream repo agent: results\n  gitStream repo agent-&gt;&gt;gitStream app: applicable automations\n  deactivate gitStream repo agent\n  deactivate gitStream GitHub action\n  loop per automation\n    loop per action\n      gitStream app-&gt;&gt;gitStream app: execute action\n      gitStream app-&gt;&gt;GitHub API: update PR\n    end\n   end</code></pre>"},{"location":"how-it-works/#the-branch-diff","title":"The branch diff","text":"<p>The branch diff is defined as the difference between the current branch and the most recent commit in the main branch, which is shared between both branches.</p> <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   branch feature\n   commit id: \"C\"\n   commit id: \"D\"\n   checkout main\n   commit id: \"E\"\n   commit id: \"F\"\n   checkout feature\n   merge main\n   commit id: \"G\"\n   commit id: \"H\"\n   checkout main\n   commit id: \"I\"\n   commit id: \"J\"</code></pre> <p>In the example above, the diff is performed between commits <code>H</code> and <code>F</code>.</p>"},{"location":"how-it-works/#automation-results","title":"Automation results","text":"<p>Eventually, the gitStream app shows the following statuses:  </p> <p> Success - when the applicable automation finished and PR is good to go </p> <p> Neutral - when there aren't any applicable automations for the PR</p> <p> Failed - when the applicable automation finished without completion</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#i-cant-see-any-action-running","title":"I can't see any action running","text":"<p>Did you install gitStream in your repo? Check that you see gitStream app on repository's Settings &gt; GitHub apps:</p> <p> In case you don't see it, visit the marketplace and install it for free: https://github.com/marketplace/gitstream-by-linearb</p> <p>Did you set the workflow files correctly? Check you have placed these 2 files in your repository, with these exact names: </p> <ol> <li><code>.cm/gitstream.cm</code></li> <li><code>.github/workflows/gitstream.yml</code></li> </ol> <p>These files need to be committed to the repository default branch (usually <code>master</code> or <code>main</code>).</p> <p>Check that you see \"gitStream workflow automation\" on the Action section in your repository:</p>  <p>Next, if you see failed action, check out the details:</p>"},{"location":"troubleshooting/#i-have-rules-that-should-have-blocked-merge-but-the-pr-can-be-merged-still","title":"I have rules that should have blocked merge, but the PR can be merged still","text":"<p>For example, when using the <code>set-required-approvals</code>  action, gitStream can ensure the PR got enough approvals before it can be merged. gitStream does that  by running as a check and marking the check conclusion as failed. In order for the PR to be blocked, gitStream should be set as a required check in the repo: instructions here.</p>"},{"location":"troubleshooting/#i-cant-set-gitstream-as-required-check","title":"I can't set gitStream as required check","text":"<p>In order for gitStream to be listed as a required check, it needs to be triggered at least once in that repo. First create a new PR so gitStream is triggered.</p> <p>Check it under repository's Settings &gt; Branches: </p>"},{"location":"troubleshooting/#i-dont-want-gitstream-to-run-on-prs-that-was-generated-by-a-bot","title":"I don't want gitStream to run on PRs that was generated by a bot","text":"<p>You can edit the <code>.github/workflows/gitstream.yml</code> and uncomment the <code>if</code> line, you can edit and replace the bot name with the bot name you want to ignore (<code>dependabot[bot]</code> in the example below):</p> .github/workflows/gitstream.yml<pre><code>jobs:\n  gitStream:\n    timeout-minutes: 5\n    # uncomment this condition, if you don't want any automation on dependabot PRs\n    if: github.actor != 'dependabot[bot]'\n    runs-on: ubuntu-latest\n    name: gitStream workflow automation\n    steps:\n      - name: Evaluate Rules\n        uses: linear-b/gitstream-github-action@v1\n</code></pre>"},{"location":"troubleshooting/#gitstream-fails-and-i-dont-understand-why","title":"gitStream fails and I don't understand why","text":"<p>gitStream check run can fail from different reasons, and these are shown in the check result. </p>  <p>Clicking the <code>Details</code> button will show more information and context.</p>"},{"location":"troubleshooting/#gitstream-fails-with-syntax-error-after-adding-new-rules","title":"gitStream fails with syntax error after adding new rules","text":"<p>IntelliJ IDEA has automatic code styling for YAML that can break the <code>.cm</code> syntax, check the following Settings/Preferences | Editor | Code Style | YAML --&gt; Spaces | Code braces and make sure it is unchecked.</p>  <p>VS Code YAML plugin by Red Hat extension <code>[vscode-yaml](https://github.com/redhat-developer/vscode-yaml)</code> has automatic code styling for YAML that can break the <code>.cm</code> syntax, make sure you disable <code>bracketSpacing</code> <pre><code>{\n    \"yaml.format.bracketSpacing\": false,\n}\n</code></pre></p>"},{"location":"troubleshooting/#not-here","title":"Not here?","text":"<p>Create a new issue in the project's issues</p>"}]}